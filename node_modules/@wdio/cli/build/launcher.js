"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _asyncExitHook = _interopRequireDefault(require("async-exit-hook"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _config = require("@wdio/config");

var _interface = _interopRequireDefault(require("./interface"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('wdio-cli:Launcher');

class Launcher {
  constructor(configFile, argv) {
    this.argv = argv;
    this.configFile = configFile;
    this.configParser = new _config.ConfigParser();
    this.configParser.addConfigFile(configFile);
    this.configParser.merge(argv);
    const config = this.configParser.getConfig();
    const capabilities = this.configParser.getCapabilities();
    const specs = this.configParser.getSpecs();

    if (config.logDir) {
      process.env.WDIO_LOG_PATH = _path.default.join(config.logDir, 'wdio.log');
    }

    const totalWorkerCnt = Array.isArray(capabilities) ? capabilities.map(c => this.configParser.getSpecs(c.specs, c.exclude).length).reduce((a, b) => a + b, 0) : 1;
    this.interface = new _interface.default(config, specs, totalWorkerCnt);
    config.runnerEnv.FORCE_COLOR = Number(this.interface.hasAnsiSupport);
    const Runner = (0, _config.initialisePlugin)(config.runner, 'runner');
    this.runner = new Runner(configFile, config);
    this.isMultiremote = !Array.isArray(capabilities);
    this.exitCode = 0;
    this.hasTriggeredExitRoutine = false;
    this.hasStartedAnyProcess = false;
    this.schedule = [];
    this.rid = [];
    this.runnerStarted = 0;
    this.runnerFailed = 0;
  }
  /**
   * run sequence
   * @return  {Promise} that only gets resolves with either an exitCode or an error
   */


  async run() {
    let config = this.configParser.getConfig();
    let caps = this.configParser.getCapabilities();
    const launcher = (0, _utils.getLauncher)(config);
    /**
     * run pre test tasks for runner plugins
     * (e.g. deploy Lambda functio to AWS)
     */

    await this.runner.initialise();
    /**
     * run onPrepare hook
     */

    await config.onPrepare(config, caps);
    log.info('Run onPrepare hook');
    await (0, _utils.runServiceHook)(launcher, 'onPrepare', config, caps);
    /**
     * catches ctrl+c event
     */

    (0, _asyncExitHook.default)(this.exitHandler.bind(this));
    const exitCode = await this.runMode(config, caps);
    /**
     * run onComplete hook
     */

    log.info('Run onComplete hook');
    await (0, _utils.runServiceHook)(launcher, 'onComplete', exitCode, config, caps);
    await config.onComplete(exitCode, config, caps, this.interface.result);
    this.interface.updateView();
    return exitCode;
  }
  /**
   * run without triggering onPrepare/onComplete hooks
   */


  runMode(config, caps) {
    /**
     * if it is an object run multiremote test
     */
    if (this.isMultiremote) {
      return new Promise(resolve => {
        this.resolve = resolve;
        this.startInstance(this.configParser.getSpecs(), caps, 0);
      });
    }
    /**
     * schedule test runs
     */


    let cid = 0;

    for (let capabilities of caps) {
      this.schedule.push({
        cid: cid++,
        caps: capabilities,
        specs: this.configParser.getSpecs(capabilities.specs, capabilities.exclude),
        availableInstances: capabilities.maxInstances || config.maxInstancesPerCapability,
        runningInstances: 0,
        seleniumServer: {
          hostname: config.hostname,
          port: config.port,
          protocol: config.protocol
        }
      });
    }

    return new Promise(resolve => {
      this.resolve = resolve;
      /**
       * fail if no specs were found or specified
       */

      if (Object.values(this.schedule).reduce((specCnt, schedule) => specCnt + schedule.specs.length, 0) === 0) {
        log.error('No specs found to run, exiting with failure');
        this.interface.updateView();
        return resolve(1);
      }
      /**
       * return immediately if no spec was run
       */


      if (this.runSpecs()) {
        resolve(0);
      }
    });
  }
  /**
   * run multiple single remote tests
   * @return {Boolean} true if all specs have been run and all instances have finished
   */


  runSpecs() {
    let config = this.configParser.getConfig();
    /**
     * stop spawning new processes when CTRL+C was triggered
     */

    if (this.hasTriggeredExitRoutine) {
      return true;
    }

    while (this.getNumberOfRunningInstances() < config.maxInstances) {
      let schedulableCaps = this.schedule
      /**
       * bail if number of errors exceeds allowed
       */
      .filter(() => {
        const filter = typeof config.bail !== 'number' || config.bail < 1 || config.bail > this.runnerFailed;
        /**
         * clear number of specs when filter is false
         */

        if (!filter) {
          this.schedule.forEach(t => {
            t.specs = [];
          });
        }

        return filter;
      })
      /**
       * make sure complete number of running instances is not higher than general maxInstances number
       */
      .filter(() => this.getNumberOfRunningInstances() < config.maxInstances)
      /**
       * make sure the capability has available capacities
       */
      .filter(a => a.availableInstances > 0)
      /**
       * make sure capability has still caps to run
       */
      .filter(a => a.specs.length > 0)
      /**
       * make sure we are running caps with less running instances first
       */
      .sort((a, b) => a.runningInstances > b.runningInstances);
      /**
       * continue if no capability were schedulable
       */

      if (schedulableCaps.length === 0) {
        break;
      }

      this.startInstance([schedulableCaps[0].specs.shift()], schedulableCaps[0].caps, schedulableCaps[0].cid, schedulableCaps[0].seleniumServer);
      schedulableCaps[0].availableInstances--;
      schedulableCaps[0].runningInstances++;
    }

    return this.getNumberOfRunningInstances() === 0 && this.getNumberOfSpecsLeft() === 0;
  }
  /**
   * gets number of all running instances
   * @return {number} number of running instances
   */


  getNumberOfRunningInstances() {
    return this.schedule.map(a => a.runningInstances).reduce((a, b) => a + b);
  }
  /**
   * get number of total specs left to complete whole suites
   * @return {number} specs left to complete suite
   */


  getNumberOfSpecsLeft() {
    return this.schedule.map(a => a.specs.length).reduce((a, b) => a + b);
  }
  /**
   * Start instance in a child process.
   * @param  {Array} specs  Specs to run
   * @param  {Number} cid  Capabilities ID
   */


  startInstance(specs, caps, cid, server) {
    var _context;

    let config = this.configParser.getConfig();
    cid = this.getRunnerId(cid);
    let processNumber = this.runnerStarted + 1; // process.debugPort defaults to 5858 and is set even when process
    // is not being debugged.

    let debugArgs = [];
    let debugType;
    let debugHost = '';
    let debugPort = process.debugPort;

    for (let i in process.execArgv) {
      const debugArgs = process.execArgv[i].match('--(debug|inspect)(?:-brk)?(?:=(.*):)?');

      if (debugArgs) {
        let [, type, host] = debugArgs;

        if (type) {
          debugType = type;
        }

        if (host) {
          debugHost = `${host}:`;
        }
      }
    }

    if (debugType) {
      debugArgs.push(`--${debugType}=${debugHost}${debugPort + processNumber}`);
    } // if you would like to add --debug-brk, use a different port, etc...


    let capExecArgs = [...(config.execArgv || []), ...(caps.execArgv || [])]; // The default value for child.fork execArgs is process.execArgs,
    // so continue to use this unless another value is specified in config.

    let defaultArgs = capExecArgs.length ? process.execArgv : []; // If an arg appears multiple times the last occurrence is used

    let execArgv = [...defaultArgs, ...debugArgs, ...capExecArgs]; // prefer launcher settings in capabilities over general launcher

    const worker = this.runner.run({
      cid,
      command: 'run',
      configFile: this.configFile,
      argv: this.argv,
      caps,
      specs,
      server,
      execArgv
    });
    worker.on('message', (_context = this.interface).onMessage.bind(_context));
    worker.on('error', (_context = this.interface).onMessage.bind(_context));
    worker.on('exit', this.endHandler.bind(this));
    this.interface.emit('job:start', {
      cid,
      caps,
      specs
    });
    this.runnerStarted++;
  }
  /**
   * generates a runner id
   * @param  {Number} cid capability id (unique identifier for a capability)
   * @return {String}     runner id (combination of cid and test id e.g. 0a, 0b, 1a, 1b ...)
   */


  getRunnerId(cid) {
    if (!this.rid[cid]) {
      this.rid[cid] = 0;
    }

    return `${cid}-${this.rid[cid]++}`;
  }
  /**
   * Close test runner process once all child processes have exited
   * @param  {Number} cid       Capabilities ID
   * @param  {Number} exitCode  exit code of child process
   */


  endHandler({
    cid,
    exitCode
  }) {
    const passed = exitCode === 0;
    this.exitCode = this.exitCode || exitCode;
    this.runnerFailed += !passed ? 1 : 0;
    this.interface.emit('job:end', {
      cid,
      passed
    }); // Update schedule now this process has ended

    if (!this.isMultiremote) {
      // get cid (capability id) from rid (runner id)
      cid = parseInt(cid, 10);
      this.schedule[cid].availableInstances++;
      this.schedule[cid].runningInstances--;
    }

    if (!this.isMultiremote && !this.runSpecs()) {
      return;
    }

    if (passed) {
      return process.nextTick(() => {
        this.interface.updateView();
        setTimeout(() => this.resolve(this.exitCode), 100);
      });
    }
    /**
     * finish with exit code 1
     */


    return process.nextTick(() => {
      this.interface.updateView();
      setTimeout(() => this.resolve(1), 100);
    });
  }
  /**
   * Make sure all started selenium sessions get closed properly and prevent
   * having dead driver processes. To do so let the runner end its Selenium
   * session first before killing
   */


  exitHandler(callback) {
    if (!callback) {
      return;
    }

    this.hasTriggeredExitRoutine = true;
    this.interface.sigintTrigger();
    return this.runner.shutdown().then(callback);
  }

}

var _default = Launcher;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sYXVuY2hlci5qcyJdLCJuYW1lcyI6WyJsb2ciLCJMYXVuY2hlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnRmlsZSIsImFyZ3YiLCJjb25maWdQYXJzZXIiLCJDb25maWdQYXJzZXIiLCJhZGRDb25maWdGaWxlIiwibWVyZ2UiLCJjb25maWciLCJnZXRDb25maWciLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJzcGVjcyIsImdldFNwZWNzIiwibG9nRGlyIiwicHJvY2VzcyIsImVudiIsIldESU9fTE9HX1BBVEgiLCJwYXRoIiwiam9pbiIsInRvdGFsV29ya2VyQ250IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiYyIsImV4Y2x1ZGUiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiYiIsImludGVyZmFjZSIsIkNMSW50ZXJmYWNlIiwicnVubmVyRW52IiwiRk9SQ0VfQ09MT1IiLCJOdW1iZXIiLCJoYXNBbnNpU3VwcG9ydCIsIlJ1bm5lciIsInJ1bm5lciIsImlzTXVsdGlyZW1vdGUiLCJleGl0Q29kZSIsImhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lIiwiaGFzU3RhcnRlZEFueVByb2Nlc3MiLCJzY2hlZHVsZSIsInJpZCIsInJ1bm5lclN0YXJ0ZWQiLCJydW5uZXJGYWlsZWQiLCJydW4iLCJjYXBzIiwibGF1bmNoZXIiLCJpbml0aWFsaXNlIiwib25QcmVwYXJlIiwiaW5mbyIsImV4aXRIYW5kbGVyIiwicnVuTW9kZSIsIm9uQ29tcGxldGUiLCJyZXN1bHQiLCJ1cGRhdGVWaWV3IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGFydEluc3RhbmNlIiwiY2lkIiwicHVzaCIsImF2YWlsYWJsZUluc3RhbmNlcyIsIm1heEluc3RhbmNlcyIsIm1heEluc3RhbmNlc1BlckNhcGFiaWxpdHkiLCJydW5uaW5nSW5zdGFuY2VzIiwic2VsZW5pdW1TZXJ2ZXIiLCJob3N0bmFtZSIsInBvcnQiLCJwcm90b2NvbCIsIk9iamVjdCIsInZhbHVlcyIsInNwZWNDbnQiLCJlcnJvciIsInJ1blNwZWNzIiwiZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzIiwic2NoZWR1bGFibGVDYXBzIiwiZmlsdGVyIiwiYmFpbCIsImZvckVhY2giLCJ0Iiwic29ydCIsInNoaWZ0IiwiZ2V0TnVtYmVyT2ZTcGVjc0xlZnQiLCJzZXJ2ZXIiLCJnZXRSdW5uZXJJZCIsInByb2Nlc3NOdW1iZXIiLCJkZWJ1Z0FyZ3MiLCJkZWJ1Z1R5cGUiLCJkZWJ1Z0hvc3QiLCJkZWJ1Z1BvcnQiLCJpIiwiZXhlY0FyZ3YiLCJtYXRjaCIsInR5cGUiLCJob3N0IiwiY2FwRXhlY0FyZ3MiLCJkZWZhdWx0QXJncyIsIndvcmtlciIsImNvbW1hbmQiLCJvbiIsIm9uTWVzc2FnZSIsImVuZEhhbmRsZXIiLCJlbWl0IiwicGFzc2VkIiwicGFyc2VJbnQiLCJuZXh0VGljayIsInNldFRpbWVvdXQiLCJjYWxsYmFjayIsInNpZ2ludFRyaWdnZXIiLCJzaHV0ZG93biIsInRoZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOzs7O0FBRUEsTUFBTUEsR0FBRyxHQUFHLHFCQUFPLG1CQUFQLENBQVo7O0FBRUEsTUFBTUMsUUFBTixDQUFlO0FBQ1hDLEVBQUFBLFdBQVcsQ0FBRUMsVUFBRixFQUFjQyxJQUFkLEVBQW9CO0FBQzNCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtELFVBQUwsR0FBa0JBLFVBQWxCO0FBRUEsU0FBS0UsWUFBTCxHQUFvQixJQUFJQyxvQkFBSixFQUFwQjtBQUNBLFNBQUtELFlBQUwsQ0FBa0JFLGFBQWxCLENBQWdDSixVQUFoQztBQUNBLFNBQUtFLFlBQUwsQ0FBa0JHLEtBQWxCLENBQXdCSixJQUF4QjtBQUVBLFVBQU1LLE1BQU0sR0FBRyxLQUFLSixZQUFMLENBQWtCSyxTQUFsQixFQUFmO0FBQ0EsVUFBTUMsWUFBWSxHQUFHLEtBQUtOLFlBQUwsQ0FBa0JPLGVBQWxCLEVBQXJCO0FBQ0EsVUFBTUMs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TCxDQUFja0IsR0FBZCxFQUFtQkUsa0JBQW5CO0FBQ0EsV0FBS3BCLFFBQUwsQ0FBY2tCLEdBQWQsRUFBbUJLLGdCQUFuQjtBQUNIOztBQUVELFFBQUksQ0FBQyxLQUFLM0IsYUFBTixJQUF1QixDQUFDLEtBQUtvQyxRQUFMLEVBQTVCLEVBQTZDO0FBQ3pDO0FBQ0g7O0FBRUQsUUFBSThCLE1BQUosRUFBWTtBQUNSLGFBQU96RixPQUFPLENBQUMyRixRQUFSLENBQWlCLE1BQU07QUFDMUIsYUFBSzVFLFNBQUwsQ0FBZTBCLFVBQWY7QUFDQW1ELFFBQUFBLFVBQVUsQ0FBQyxNQUFNLEtBQUtqRCxPQUFMLENBQWEsS0FBS25CLFFBQWxCLENBQVAsRUFBb0MsR0FBcEMsQ0FBVjtBQUNILE9BSE0sQ0FBUDtBQUlIO0FBRUQ7Ozs7O0FBR0EsV0FBT3hCLE9BQU8sQ0FBQzJGLFFBQVIsQ0FBaUIsTUFBTTtBQUMxQixXQUFLNUUsU0FBTCxDQUFlMEIsVUFBZjtBQUNBbUQsTUFBQUEsVUFBVSxDQUFDLE1BQU0sS0FBS2pELE9BQUwsQ0FBYSxDQUFiLENBQVAsRUFBd0IsR0FBeEIsQ0FBVjtBQUNILEtBSE0sQ0FBUDtBQUlIO0FBRUQ7Ozs7Ozs7QUFLQU4sRUFBQUEsV0FBVyxDQUFFd0QsUUFBRixFQUFZO0FBQ25CLFFBQUksQ0FBQ0EsUUFBTCxFQUFlO0FBQ1g7QUFDSDs7QUFFRCxTQUFLcEUsdUJBQUwsR0FBK0IsSUFBL0I7QUFDQSxTQUFLVixTQUFMLENBQWUrRSxhQUFmO0FBQ0EsV0FBTyxLQUFLeEUsTUFBTCxDQUFZeUUsUUFBWixHQUF1QkMsSUFBdkIsQ0FBNEJILFFBQTVCLENBQVA7QUFDSDs7QUF4VlU7O2VBMlZBNUcsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgZXhpdEhvb2sgZnJvbSAnYXN5bmMtZXhpdC1ob29rJ1xuXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ0B3ZGlvL2xvZ2dlcidcbmltcG9ydCB7IENvbmZpZ1BhcnNlciwgaW5pdGlhbGlzZVBsdWdpbiB9IGZyb20gJ0B3ZGlvL2NvbmZpZydcblxuaW1wb3J0IENMSW50ZXJmYWNlIGZyb20gJy4vaW50ZXJmYWNlJ1xuaW1wb3J0IHsgZ2V0TGF1bmNoZXIsIHJ1blNlcnZpY2VIb29rIH0gZnJvbSAnLi91dGlscydcblxuY29uc3QgbG9nID0gbG9nZ2VyKCd3ZGlvLWNsaTpMYXVuY2hlcicpXG5cbmNsYXNzIExhdW5jaGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoY29uZmlnRmlsZSwgYXJndikge1xuICAgICAgICB0aGlzLmFyZ3YgPSBhcmd2XG4gICAgICAgIHRoaXMuY29uZmlnRmlsZSA9IGNvbmZpZ0ZpbGVcblxuICAgICAgICB0aGlzLmNvbmZpZ1BhcnNlciA9IG5ldyBDb25maWdQYXJzZXIoKVxuICAgICAgICB0aGlzLmNvbmZpZ1BhcnNlci5hZGRDb25maWdGaWxlKGNvbmZpZ0ZpbGUpXG4gICAgICAgIHRoaXMuY29uZmlnUGFyc2VyLm1lcmdlKGFyZ3YpXG5cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q29uZmlnKClcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q2FwYWJpbGl0aWVzKClcbiAgICAgICAgY29uc3Qgc3BlY3MgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRTcGVjcygpXG5cbiAgICAgICAgaWYgKGNvbmZpZy5sb2dEaXIpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LldESU9fTE9HX1BBVEggPSBwYXRoLmpvaW4oY29uZmlnLmxvZ0RpciwgJ3dkaW8ubG9nJylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdGFsV29ya2VyQ250ID0gQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICA/IGNhcGFiaWxpdGllc1xuICAgICAgICAgICAgICAgIC5tYXAoKGMpID0+IHRoaXMuY29uZmlnUGFyc2VyLmdldFNwZWNzKGMuc3BlY3MsIGMuZXhjbHVkZSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKVxuICAgICAgICAgICAgOiAxXG5cbiAgICAgICAgdGhpcy5pbnRlcmZhY2UgPSBuZXcgQ0xJbnRlcmZhY2UoY29uZmlnLCBzcGVjcywgdG90YWxXb3JrZXJDbnQpXG4gICAgICAgIGNvbmZpZy5ydW5uZXJFbnYuRk9SQ0VfQ09MT1IgPSBOdW1iZXIodGhpcy5pbnRlcmZhY2UuaGFzQW5zaVN1cHBvcnQpXG5cbiAgICAgICAgY29uc3QgUnVubmVyID0gaW5pdGlhbGlzZVBsdWdpbihjb25maWcucnVubmVyLCAncnVubmVyJylcbiAgICAgICAgdGhpcy5ydW5uZXIgPSBuZXcgUnVubmVyKGNvbmZpZ0ZpbGUsIGNvbmZpZylcblxuICAgICAgICB0aGlzLmlzTXVsdGlyZW1vdGUgPSAhQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpXG4gICAgICAgIHRoaXMuZXhpdENvZGUgPSAwXG4gICAgICAgIHRoaXMuaGFzVHJpZ2dlcmVkRXhpdFJvdXRpbmUgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc1N0YXJ0ZWRBbnlQcm9jZXNzID0gZmFsc2VcbiAgICAgICAgdGhpcy5zY2hlZHVsZSA9IFtdXG4gICAgICAgIHRoaXMucmlkID0gW11cbiAgICAgICAgdGhpcy5ydW5uZXJTdGFydGVkID0gMFxuICAgICAgICB0aGlzLnJ1bm5lckZhaWxlZCA9IDBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gc2VxdWVuY2VcbiAgICAgKiBAcmV0dXJuICB7UHJvbWlzZX0gdGhhdCBvbmx5IGdldHMgcmVzb2x2ZXMgd2l0aCBlaXRoZXIgYW4gZXhpdENvZGUgb3IgYW4gZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBydW4gKCkge1xuICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q29uZmlnKClcbiAgICAgICAgbGV0IGNhcHMgPSB0aGlzLmNvbmZpZ1BhcnNlci5nZXRDYXBhYmlsaXRpZXMoKVxuICAgICAgICBjb25zdCBsYXVuY2hlciA9IGdldExhdW5jaGVyKGNvbmZpZylcblxuICAgICAgICAvKipcbiAgICAgICAgICogcnVuIHByZSB0ZXN0IHRhc2tzIGZvciBydW5uZXIgcGx1Z2luc1xuICAgICAgICAgKiAoZS5nLiBkZXBsb3kgTGFtYmRhIGZ1bmN0aW8gdG8gQVdTKVxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgdGhpcy5ydW5uZXIuaW5pdGlhbGlzZSgpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJ1biBvblByZXBhcmUgaG9va1xuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgY29uZmlnLm9uUHJlcGFyZShjb25maWcsIGNhcHMpXG4gICAgICAgIGxvZy5pbmZvKCdSdW4gb25QcmVwYXJlIGhvb2snKVxuICAgICAgICBhd2FpdCBydW5TZXJ2aWNlSG9vayhsYXVuY2hlciwgJ29uUHJlcGFyZScsIGNvbmZpZywgY2FwcylcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2F0Y2hlcyBjdHJsK2MgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGV4aXRIb29rKDo6dGhpcy5leGl0SGFuZGxlcilcblxuICAgICAgICBjb25zdCBleGl0Q29kZSA9IGF3YWl0IHRoaXMucnVuTW9kZShjb25maWcsIGNhcHMpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJ1biBvbkNvbXBsZXRlIGhvb2tcbiAgICAgICAgICovXG4gICAgICAgIGxvZy5pbmZvKCdSdW4gb25Db21wbGV0ZSBob29rJylcbiAgICAgICAgYXdhaXQgcnVuU2VydmljZUhvb2sobGF1bmNoZXIsICdvbkNvbXBsZXRlJywgZXhpdENvZGUsIGNvbmZpZywgY2FwcylcbiAgICAgICAgYXdhaXQgY29uZmlnLm9uQ29tcGxldGUoZXhpdENvZGUsIGNvbmZpZywgY2FwcywgdGhpcy5pbnRlcmZhY2UucmVzdWx0KVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLnVwZGF0ZVZpZXcoKVxuICAgICAgICByZXR1cm4gZXhpdENvZGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gd2l0aG91dCB0cmlnZ2VyaW5nIG9uUHJlcGFyZS9vbkNvbXBsZXRlIGhvb2tzXG4gICAgICovXG4gICAgcnVuTW9kZSAoY29uZmlnLCBjYXBzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiBpdCBpcyBhbiBvYmplY3QgcnVuIG11bHRpcmVtb3RlIHRlc3RcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGlyZW1vdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SW5zdGFuY2UodGhpcy5jb25maWdQYXJzZXIuZ2V0U3BlY3MoKSwgY2FwcywgMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc2NoZWR1bGUgdGVzdCBydW5zXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgY2lkID0gMFxuICAgICAgICBmb3IgKGxldCBjYXBhYmlsaXRpZXMgb2YgY2Fwcykge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBjaWQ6IGNpZCsrLFxuICAgICAgICAgICAgICAgIGNhcHM6IGNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICBzcGVjczogdGhpcy5jb25maWdQYXJzZXIuZ2V0U3BlY3MoY2FwYWJpbGl0aWVzLnNwZWNzLCBjYXBhYmlsaXRpZXMuZXhjbHVkZSksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSW5zdGFuY2VzOiBjYXBhYmlsaXRpZXMubWF4SW5zdGFuY2VzIHx8IGNvbmZpZy5tYXhJbnN0YW5jZXNQZXJDYXBhYmlsaXR5LFxuICAgICAgICAgICAgICAgIHJ1bm5pbmdJbnN0YW5jZXM6IDAsXG4gICAgICAgICAgICAgICAgc2VsZW5pdW1TZXJ2ZXI6IHsgaG9zdG5hbWU6IGNvbmZpZy5ob3N0bmFtZSwgcG9ydDogY29uZmlnLnBvcnQsIHByb3RvY29sOiBjb25maWcucHJvdG9jb2wgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGZhaWwgaWYgbm8gc3BlY3Mgd2VyZSBmb3VuZCBvciBzcGVjaWZpZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXModGhpcy5zY2hlZHVsZSkucmVkdWNlKChzcGVjQ250LCBzY2hlZHVsZSkgPT4gc3BlY0NudCArIHNjaGVkdWxlLnNwZWNzLmxlbmd0aCwgMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ05vIHNwZWNzIGZvdW5kIHRvIHJ1biwgZXhpdGluZyB3aXRoIGZhaWx1cmUnKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLnVwZGF0ZVZpZXcoKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmV0dXJuIGltbWVkaWF0ZWx5IGlmIG5vIHNwZWMgd2FzIHJ1blxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5ydW5TcGVjcygpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJ1biBtdWx0aXBsZSBzaW5nbGUgcmVtb3RlIHRlc3RzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhbGwgc3BlY3MgaGF2ZSBiZWVuIHJ1biBhbmQgYWxsIGluc3RhbmNlcyBoYXZlIGZpbmlzaGVkXG4gICAgICovXG4gICAgcnVuU3BlY3MgKCkge1xuICAgICAgICBsZXQgY29uZmlnID0gdGhpcy5jb25maWdQYXJzZXIuZ2V0Q29uZmlnKClcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RvcCBzcGF3bmluZyBuZXcgcHJvY2Vzc2VzIHdoZW4gQ1RSTCtDIHdhcyB0cmlnZ2VyZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmhhc1RyaWdnZXJlZEV4aXRSb3V0aW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzKCkgPCBjb25maWcubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgc2NoZWR1bGFibGVDYXBzID0gdGhpcy5zY2hlZHVsZVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIGJhaWwgaWYgbnVtYmVyIG9mIGVycm9ycyBleGNlZWRzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAuZmlsdGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gdHlwZW9mIGNvbmZpZy5iYWlsICE9PSAnbnVtYmVyJyB8fCBjb25maWcuYmFpbCA8IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJhaWwgPiB0aGlzLnJ1bm5lckZhaWxlZFxuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBjbGVhciBudW1iZXIgb2Ygc3BlY3Mgd2hlbiBmaWx0ZXIgaXMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlLmZvckVhY2goKHQpID0+IHsgdC5zcGVjcyA9IFtdIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBtYWtlIHN1cmUgY29tcGxldGUgbnVtYmVyIG9mIHJ1bm5pbmcgaW5zdGFuY2VzIGlzIG5vdCBoaWdoZXIgdGhhbiBnZW5lcmFsIG1heEluc3RhbmNlcyBudW1iZXJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAuZmlsdGVyKCgpID0+IHRoaXMuZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzKCkgPCBjb25maWcubWF4SW5zdGFuY2VzKVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG1ha2Ugc3VyZSB0aGUgY2FwYWJpbGl0eSBoYXMgYXZhaWxhYmxlIGNhcGFjaXRpZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAuZmlsdGVyKChhKSA9PiBhLmF2YWlsYWJsZUluc3RhbmNlcyA+IDApXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogbWFrZSBzdXJlIGNhcGFiaWxpdHkgaGFzIHN0aWxsIGNhcHMgdG8gcnVuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYS5zcGVjcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG1ha2Ugc3VyZSB3ZSBhcmUgcnVubmluZyBjYXBzIHdpdGggbGVzcyBydW5uaW5nIGluc3RhbmNlcyBmaXJzdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnJ1bm5pbmdJbnN0YW5jZXMgPiBiLnJ1bm5pbmdJbnN0YW5jZXMpXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY29udGludWUgaWYgbm8gY2FwYWJpbGl0eSB3ZXJlIHNjaGVkdWxhYmxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzY2hlZHVsYWJsZUNhcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGFydEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIFtzY2hlZHVsYWJsZUNhcHNbMF0uc3BlY3Muc2hpZnQoKV0sXG4gICAgICAgICAgICAgICAgc2NoZWR1bGFibGVDYXBzWzBdLmNhcHMsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGFibGVDYXBzWzBdLmNpZCxcbiAgICAgICAgICAgICAgICBzY2hlZHVsYWJsZUNhcHNbMF0uc2VsZW5pdW1TZXJ2ZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHNjaGVkdWxhYmxlQ2Fwc1swXS5hdmFpbGFibGVJbnN0YW5jZXMtLVxuICAgICAgICAgICAgc2NoZWR1bGFibGVDYXBzWzBdLnJ1bm5pbmdJbnN0YW5jZXMrK1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyT2ZSdW5uaW5nSW5zdGFuY2VzKCkgPT09IDAgJiYgdGhpcy5nZXROdW1iZXJPZlNwZWNzTGVmdCgpID09PSAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0cyBudW1iZXIgb2YgYWxsIHJ1bm5pbmcgaW5zdGFuY2VzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBudW1iZXIgb2YgcnVubmluZyBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICBnZXROdW1iZXJPZlJ1bm5pbmdJbnN0YW5jZXMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZS5tYXAoKGEpID0+IGEucnVubmluZ0luc3RhbmNlcykucmVkdWNlKChhLCBiKSA9PiBhICsgYilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgbnVtYmVyIG9mIHRvdGFsIHNwZWNzIGxlZnQgdG8gY29tcGxldGUgd2hvbGUgc3VpdGVzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBzcGVjcyBsZWZ0IHRvIGNvbXBsZXRlIHN1aXRlXG4gICAgICovXG4gICAgZ2V0TnVtYmVyT2ZTcGVjc0xlZnQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZS5tYXAoKGEpID0+IGEuc3BlY3MubGVuZ3RoKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGluc3RhbmNlIGluIGEgY2hpbGQgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gc3BlY3MgIFNwZWNzIHRvIHJ1blxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2lkICBDYXBhYmlsaXRpZXMgSURcbiAgICAgKi9cbiAgICBzdGFydEluc3RhbmNlIChzcGVjcywgY2FwcywgY2lkLCBzZXJ2ZXIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG4gICAgICAgIGNpZCA9IHRoaXMuZ2V0UnVubmVySWQoY2lkKVxuICAgICAgICBsZXQgcHJvY2Vzc051bWJlciA9IHRoaXMucnVubmVyU3RhcnRlZCArIDFcblxuICAgICAgICAvLyBwcm9jZXNzLmRlYnVnUG9ydCBkZWZhdWx0cyB0byA1ODU4IGFuZCBpcyBzZXQgZXZlbiB3aGVuIHByb2Nlc3NcbiAgICAgICAgLy8gaXMgbm90IGJlaW5nIGRlYnVnZ2VkLlxuICAgICAgICBsZXQgZGVidWdBcmdzID0gW11cbiAgICAgICAgbGV0IGRlYnVnVHlwZVxuICAgICAgICBsZXQgZGVidWdIb3N0ID0gJydcbiAgICAgICAgbGV0IGRlYnVnUG9ydCA9IHByb2Nlc3MuZGVidWdQb3J0XG4gICAgICAgIGZvciAobGV0IGkgaW4gcHJvY2Vzcy5leGVjQXJndikge1xuICAgICAgICAgICAgY29uc3QgZGVidWdBcmdzID0gcHJvY2Vzcy5leGVjQXJndltpXS5tYXRjaCgnLS0oZGVidWd8aW5zcGVjdCkoPzotYnJrKT8oPzo9KC4qKTopPycpXG4gICAgICAgICAgICBpZiAoZGVidWdBcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IFssIHR5cGUsIGhvc3RdID0gZGVidWdBcmdzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdUeXBlID0gdHlwZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0hvc3QgPSBgJHtob3N0fTpgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlYnVnVHlwZSkge1xuICAgICAgICAgICAgZGVidWdBcmdzLnB1c2goYC0tJHtkZWJ1Z1R5cGV9PSR7ZGVidWdIb3N0fSR7KGRlYnVnUG9ydCArIHByb2Nlc3NOdW1iZXIpfWApXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB5b3Ugd291bGQgbGlrZSB0byBhZGQgLS1kZWJ1Zy1icmssIHVzZSBhIGRpZmZlcmVudCBwb3J0LCBldGMuLi5cbiAgICAgICAgbGV0IGNhcEV4ZWNBcmdzID0gW1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5leGVjQXJndiB8fCBbXSksXG4gICAgICAgICAgICAuLi4oY2Fwcy5leGVjQXJndiB8fCBbXSlcbiAgICAgICAgXVxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBjaGlsZC5mb3JrIGV4ZWNBcmdzIGlzIHByb2Nlc3MuZXhlY0FyZ3MsXG4gICAgICAgIC8vIHNvIGNvbnRpbnVlIHRvIHVzZSB0aGlzIHVubGVzcyBhbm90aGVyIHZhbHVlIGlzIHNwZWNpZmllZCBpbiBjb25maWcuXG4gICAgICAgIGxldCBkZWZhdWx0QXJncyA9IChjYXBFeGVjQXJncy5sZW5ndGgpID8gcHJvY2Vzcy5leGVjQXJndiA6IFtdXG5cbiAgICAgICAgLy8gSWYgYW4gYXJnIGFwcGVhcnMgbXVsdGlwbGUgdGltZXMgdGhlIGxhc3Qgb2NjdXJyZW5jZSBpcyB1c2VkXG4gICAgICAgIGxldCBleGVjQXJndiA9IFsgLi4uZGVmYXVsdEFyZ3MsIC4uLmRlYnVnQXJncywgLi4uY2FwRXhlY0FyZ3MgXVxuXG4gICAgICAgIC8vIHByZWZlciBsYXVuY2hlciBzZXR0aW5ncyBpbiBjYXBhYmlsaXRpZXMgb3ZlciBnZW5lcmFsIGxhdW5jaGVyXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMucnVubmVyLnJ1bih7XG4gICAgICAgICAgICBjaWQsXG4gICAgICAgICAgICBjb21tYW5kOiAncnVuJyxcbiAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IHRoaXMuY29uZmlnRmlsZSxcbiAgICAgICAgICAgIGFyZ3Y6IHRoaXMuYXJndixcbiAgICAgICAgICAgIGNhcHMsXG4gICAgICAgICAgICBzcGVjcyxcbiAgICAgICAgICAgIHNlcnZlcixcbiAgICAgICAgICAgIGV4ZWNBcmd2XG4gICAgICAgIH0pXG4gICAgICAgIHdvcmtlci5vbignbWVzc2FnZScsIDo6dGhpcy5pbnRlcmZhY2Uub25NZXNzYWdlKVxuICAgICAgICB3b3JrZXIub24oJ2Vycm9yJywgOjp0aGlzLmludGVyZmFjZS5vbk1lc3NhZ2UpXG4gICAgICAgIHdvcmtlci5vbignZXhpdCcsIDo6dGhpcy5lbmRIYW5kbGVyKVxuXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLmVtaXQoJ2pvYjpzdGFydCcsIHsgY2lkLCBjYXBzLCBzcGVjcyB9KVxuICAgICAgICB0aGlzLnJ1bm5lclN0YXJ0ZWQrK1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlcyBhIHJ1bm5lciBpZFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY2lkIGNhcGFiaWxpdHkgaWQgKHVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIGNhcGFiaWxpdHkpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAgICAgcnVubmVyIGlkIChjb21iaW5hdGlvbiBvZiBjaWQgYW5kIHRlc3QgaWQgZS5nLiAwYSwgMGIsIDFhLCAxYiAuLi4pXG4gICAgICovXG4gICAgZ2V0UnVubmVySWQgKGNpZCkge1xuICAgICAgICBpZiAoIXRoaXMucmlkW2NpZF0pIHtcbiAgICAgICAgICAgIHRoaXMucmlkW2NpZF0gPSAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2NpZH0tJHt0aGlzLnJpZFtjaWRdKyt9YFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRlc3QgcnVubmVyIHByb2Nlc3Mgb25jZSBhbGwgY2hpbGQgcHJvY2Vzc2VzIGhhdmUgZXhpdGVkXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBjaWQgICAgICAgQ2FwYWJpbGl0aWVzIElEXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBleGl0Q29kZSAgZXhpdCBjb2RlIG9mIGNoaWxkIHByb2Nlc3NcbiAgICAgKi9cbiAgICBlbmRIYW5kbGVyICh7IGNpZCwgZXhpdENvZGUgfSkge1xuICAgICAgICBjb25zdCBwYXNzZWQgPSBleGl0Q29kZSA9PT0gMFxuICAgICAgICB0aGlzLmV4aXRDb2RlID0gdGhpcy5leGl0Q29kZSB8fCBleGl0Q29kZVxuICAgICAgICB0aGlzLnJ1bm5lckZhaWxlZCArPSAhcGFzc2VkID8gMSA6IDBcbiAgICAgICAgdGhpcy5pbnRlcmZhY2UuZW1pdCgnam9iOmVuZCcsIHsgY2lkLCBwYXNzZWQgfSlcblxuICAgICAgICAvLyBVcGRhdGUgc2NoZWR1bGUgbm93IHRoaXMgcHJvY2VzcyBoYXMgZW5kZWRcbiAgICAgICAgaWYgKCF0aGlzLmlzTXVsdGlyZW1vdGUpIHtcbiAgICAgICAgICAgIC8vIGdldCBjaWQgKGNhcGFiaWxpdHkgaWQpIGZyb20gcmlkIChydW5uZXIgaWQpXG4gICAgICAgICAgICBjaWQgPSBwYXJzZUludChjaWQsIDEwKVxuXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlW2NpZF0uYXZhaWxhYmxlSW5zdGFuY2VzKytcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVbY2lkXS5ydW5uaW5nSW5zdGFuY2VzLS1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc011bHRpcmVtb3RlICYmICF0aGlzLnJ1blNwZWNzKCkpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLnVwZGF0ZVZpZXcoKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNvbHZlKHRoaXMuZXhpdENvZGUpLCAxMDApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmlzaCB3aXRoIGV4aXQgY29kZSAxXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZS51cGRhdGVWaWV3KClcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXNvbHZlKDEpLCAxMDApXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIGFsbCBzdGFydGVkIHNlbGVuaXVtIHNlc3Npb25zIGdldCBjbG9zZWQgcHJvcGVybHkgYW5kIHByZXZlbnRcbiAgICAgKiBoYXZpbmcgZGVhZCBkcml2ZXIgcHJvY2Vzc2VzLiBUbyBkbyBzbyBsZXQgdGhlIHJ1bm5lciBlbmQgaXRzIFNlbGVuaXVtXG4gICAgICogc2Vzc2lvbiBmaXJzdCBiZWZvcmUga2lsbGluZ1xuICAgICAqL1xuICAgIGV4aXRIYW5kbGVyIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzVHJpZ2dlcmVkRXhpdFJvdXRpbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlLnNpZ2ludFRyaWdnZXIoKVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uZXIuc2h1dGRvd24oKS50aGVuKGNhbGxiYWNrKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF1bmNoZXJcbiJdfQ==