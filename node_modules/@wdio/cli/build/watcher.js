"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _chokidar = _interopRequireDefault(require("chokidar"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _lodash = _interopRequireDefault(require("lodash.pickby"));

var _lodash2 = _interopRequireDefault(require("lodash.flattendeep"));

var _lodash3 = _interopRequireDefault(require("lodash.union"));

var _launcher = _interopRequireDefault(require("./launcher.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('wdio-cli:watch');

class Watcher {
  constructor(configFile, argv) {
    log.info('Starting launcher in watch mode');
    this.launcher = new _launcher.default(configFile, argv);
    this.totalWorkerCnt = this.launcher.interface.totalWorkerCnt;
    this.argv = argv;
    const specs = this.launcher.configParser.getSpecs();
    this.specs = [...specs, ...(0, _lodash3.default)((0, _lodash2.default)(this.launcher.configParser.getCapabilities().map(cap => cap.specs || [])))];
    this.isRunningTests = false;
  }

  async watch() {
    /**
     * listen on spec changes and rerun specific spec file
     */
    _chokidar.default.watch(this.specs, {
      ignoreInitial: true
    }).on('add', this.getFileListener()).on('change', this.getFileListener());
    /**
     * listen on filesToWatch changes an rerun complete suite
     */


    const {
      filesToWatch
    } = this.launcher.configParser.getConfig();

    if (filesToWatch.length) {
      _chokidar.default.watch(filesToWatch, {
        ignoreInitial: true
      }).on('add', this.getFileListener(false)).on('change', this.getFileListener(false));
    }
    /**
     * run initial test suite
     */


    await this.launcher.run();
    this.launcher.interface.updateView();
  }
  /**
   * return file listener callback that calls `run` method
   * @param  {Boolean}  [passOnFile=true]  if true pass on file change as parameter
   * @return {Function}                    chokidar event callback
   */


  getFileListener(passOnFile = true) {
    return spec => this.run(Object.assign({}, this.argv, passOnFile ? {
      spec
    } : {}));
  }
  /**
   * helper method to get workers from worker pool of wdio runner
   * @param  {Function} pickBy             filter by property value (see lodash.pickBy)
   * @param  {Boolean}  includeBusyWorker  don't filter out busy worker (default: false)
   * @return {Object}                      Object with workers, e.g. {'0-0': { ... }}
   */


  getWorkers(pickByFn, includeBusyWorker) {
    let workers = this.launcher.runner.workerPool;

    if (typeof pickByFn === 'function') {
      workers = (0, _lodash.default)(workers, pickByFn);
    }
    /**
     * filter out busy workers, only skip if explicitely desired
     */


    if (!includeBusyWorker) {
      workers = (0, _lodash.default)(workers, worker => !worker.isBusy);
    }

    return workers;
  }
  /**
   * run workers with params
   * @param  {Object} [params={}]  parameters to run the worker with
   */


  run(params = {}) {
    const workers = this.getWorkers(params.spec ? worker => worker.specs.includes(params.spec) : null);
    /**
     * don't do anything if no worker was found
     */

    if (Object.keys(workers).length === 0) {
      return;
    }
    /**
     * clean up interface
     */


    this.cleanUp();
    /**
     * update total worker count interface
     * ToDo: this should have a cleaner solution
     */

    this.launcher.interface.totalWorkerCnt = Object.entries(workers).length;
    /**
     * trigger new run for non busy worker
     */

    for (const [, worker] of Object.entries(workers)) {
      const {
        cid,
        caps,
        specs,
        sessionId
      } = worker;
      const argv = Object.assign({
        sessionId
      }, params);
      worker.postMessage('run', argv);
      this.launcher.interface.emit('job:start', {
        cid,
        caps,
        specs
      });
    }
  }

  cleanUp() {
    this.launcher.interface.setup();
    this.launcher.interface.updateView();
  }

}

exports.default = Watcher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93YXRjaGVyLmpzIl0sIm5hbWVzIjpbImxvZyIsIldhdGNoZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZ0ZpbGUiLCJhcmd2IiwiaW5mbyIsImxhdW5jaGVyIiwiTGF1bmNoZXIiLCJ0b3RhbFdvcmtlckNudCIsImludGVyZmFjZSIsInNwZWNzIiwiY29uZmlnUGFyc2VyIiwiZ2V0U3BlY3MiLCJnZXRDYXBhYmlsaXRpZXMiLCJtYXAiLCJjYXAiLCJpc1J1bm5pbmdUZXN0cyIsIndhdGNoIiwiY2hva2lkYXIiLCJpZ25vcmVJbml0aWFsIiwib24iLCJnZXRGaWxlTGlzdGVuZXIiLCJmaWxlc1RvV2F0Y2giLCJnZXRDb25maWciLCJsZW5ndGgiLCJydW4iLCJ1cGRhdGVWaWV3IiwicGFzc09uRmlsZSIsInNwZWMiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRXb3JrZXJzIiwicGlja0J5Rm4iLCJpbmNsdWRlQnVzeVdvcmtlciIsIndvcmtlcnMiLCJydW5uZXIiLCJ3b3JrZXJQb29sIiwid29ya2VyIiwiaXNCdXN5IiwicGFyYW1zIiwiaW5jbHVkZXMiLCJrZXlzIiwiY2xlYW5VcCIsImVudHJpZXMiLCJjaWQiLCJjYXBzIiwic2Vzc2lvbklkIiwicG9zdE1lc3NhZ2UiLCJlbWl0Iiwic2V0dXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBRUEsTUFBTUEsR0FBRyxHQUFHLHFCQUFPLGdCQUFQLENBQVo7O0FBR2UsTUFBTUMsT0FBTixDQUFjO0FBQ3pCQyxFQUFBQSxXQUFXLENBQUVDLFVBQUYsRUFBY0MsSUFBZCxFQUFvQjtBQUMzQkosSUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVMsaUNBQVQ7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLElBQUlDLGlCQUFKLENBQWFKLFVBQWIsRUFBeUJDLElBQXpCLENBQWhCO0FBQ0EsU0FBS0ksY0FBTCxHQUFzQixLQUFLRixRQUFMLENBQWNHLFNB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QUwsQ0FBY0csU0FBZCxDQUF3QkQsY0FBeEIsR0FBeUNxQixNQUFNLENBQUNjLE9BQVAsQ0FBZVQsT0FBZixFQUF3QlYsTUFBakU7QUFFQTs7OztBQUdBLFNBQUssTUFBTSxHQUFHYSxNQUFILENBQVgsSUFBeUJSLE1BQU0sQ0FBQ2MsT0FBUCxDQUFlVCxPQUFmLENBQXpCLEVBQWtEO0FBQzlDLFlBQU07QUFBRVUsUUFBQUEsR0FBRjtBQUFPQyxRQUFBQSxJQUFQO0FBQWFuQyxRQUFBQSxLQUFiO0FBQW9Cb0MsUUFBQUE7QUFBcEIsVUFBa0NULE1BQXhDO0FBQ0EsWUFBTWpDLElBQUksR0FBR3lCLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjO0FBQUVnQixRQUFBQTtBQUFGLE9BQWQsRUFBNkJQLE1BQTdCLENBQWI7QUFDQUYsTUFBQUEsTUFBTSxDQUFDVSxXQUFQLENBQW1CLEtBQW5CLEVBQTBCM0MsSUFBMUI7QUFDQSxXQUFLRSxRQUFMLENBQWNHLFNBQWQsQ0FBd0J1QyxJQUF4QixDQUE2QixXQUE3QixFQUEwQztBQUFFSixRQUFBQSxHQUFGO0FBQU9DLFFBQUFBLElBQVA7QUFBYW5DLFFBQUFBO0FBQWIsT0FBMUM7QUFDSDtBQUNKOztBQUVEZ0MsRUFBQUEsT0FBTyxHQUFJO0FBQ1AsU0FBS3BDLFFBQUwsQ0FBY0csU0FBZCxDQUF3QndDLEtBQXhCO0FBQ0EsU0FBSzNDLFFBQUwsQ0FBY0csU0FBZCxDQUF3QmlCLFVBQXhCO0FBQ0g7O0FBcEh3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaG9raWRhciBmcm9tICdjaG9raWRhcidcbmltcG9ydCBsb2dnZXIgZnJvbSAnQHdkaW8vbG9nZ2VyJ1xuaW1wb3J0IHBpY2tCeSBmcm9tICdsb2Rhc2gucGlja2J5J1xuaW1wb3J0IGZsYXR0ZW5EZWVwIGZyb20gJ2xvZGFzaC5mbGF0dGVuZGVlcCdcbmltcG9ydCB1bmlvbiBmcm9tICdsb2Rhc2gudW5pb24nXG5cbmltcG9ydCBMYXVuY2hlciBmcm9tICcuL2xhdW5jaGVyLmpzJ1xuXG5jb25zdCBsb2cgPSBsb2dnZXIoJ3dkaW8tY2xpOndhdGNoJylcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoY29uZmlnRmlsZSwgYXJndikge1xuICAgICAgICBsb2cuaW5mbygnU3RhcnRpbmcgbGF1bmNoZXIgaW4gd2F0Y2ggbW9kZScpXG4gICAgICAgIHRoaXMubGF1bmNoZXIgPSBuZXcgTGF1bmNoZXIoY29uZmlnRmlsZSwgYXJndilcbiAgICAgICAgdGhpcy50b3RhbFdvcmtlckNudCA9IHRoaXMubGF1bmNoZXIuaW50ZXJmYWNlLnRvdGFsV29ya2VyQ250XG4gICAgICAgIHRoaXMuYXJndiA9IGFyZ3ZcblxuICAgICAgICBjb25zdCBzcGVjcyA9IHRoaXMubGF1bmNoZXIuY29uZmlnUGFyc2VyLmdldFNwZWNzKClcbiAgICAgICAgdGhpcy5zcGVjcyA9IFtcbiAgICAgICAgICAgIC4uLnNwZWNzLFxuICAgICAgICAgICAgLi4udW5pb24oZmxhdHRlbkRlZXAoXG4gICAgICAgICAgICAgICAgdGhpcy5sYXVuY2hlci5jb25maWdQYXJzZXIuZ2V0Q2FwYWJpbGl0aWVzKCkubWFwKGNhcCA9PiBjYXAuc3BlY3MgfHwgW10pXG4gICAgICAgICAgICApKVxuICAgICAgICBdXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nVGVzdHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGFzeW5jIHdhdGNoICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxpc3RlbiBvbiBzcGVjIGNoYW5nZXMgYW5kIHJlcnVuIHNwZWNpZmljIHNwZWMgZmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgY2hva2lkYXIud2F0Y2godGhpcy5zcGVjcywgeyBpZ25vcmVJbml0aWFsOiB0cnVlIH0pXG4gICAgICAgICAgICAub24oJ2FkZCcsIHRoaXMuZ2V0RmlsZUxpc3RlbmVyKCkpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuZ2V0RmlsZUxpc3RlbmVyKCkpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxpc3RlbiBvbiBmaWxlc1RvV2F0Y2ggY2hhbmdlcyBhbiByZXJ1biBjb21wbGV0ZSBzdWl0ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBmaWxlc1RvV2F0Y2ggfSA9IHRoaXMubGF1bmNoZXIuY29uZmlnUGFyc2VyLmdldENvbmZpZygpXG4gICAgICAgIGlmIChmaWxlc1RvV2F0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaG9raWRhci53YXRjaChmaWxlc1RvV2F0Y2gsIHsgaWdub3JlSW5pdGlhbDogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIC5vbignYWRkJywgdGhpcy5nZXRGaWxlTGlzdGVuZXIoZmFsc2UpKVxuICAgICAgICAgICAgICAgIC5vbignY2hhbmdlJywgdGhpcy5nZXRGaWxlTGlzdGVuZXIoZmFsc2UpKVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJ1biBpbml0aWFsIHRlc3Qgc3VpdGVcbiAgICAgICAgICovXG4gICAgICAgIGF3YWl0IHRoaXMubGF1bmNoZXIucnVuKClcbiAgICAgICAgdGhpcy5sYXVuY2hlci5pbnRlcmZhY2UudXBkYXRlVmlldygpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZpbGUgbGlzdGVuZXIgY2FsbGJhY2sgdGhhdCBjYWxscyBgcnVuYCBtZXRob2RcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSAgW3Bhc3NPbkZpbGU9dHJ1ZV0gIGlmIHRydWUgcGFzcyBvbiBmaWxlIGNoYW5nZSBhcyBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICAgIGNob2tpZGFyIGV2ZW50IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0RmlsZUxpc3RlbmVyIChwYXNzT25GaWxlID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gKHNwZWMpID0+IHRoaXMucnVuKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hcmd2LCBwYXNzT25GaWxlID8geyBzcGVjIH0gOiB7fSlcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlbHBlciBtZXRob2QgdG8gZ2V0IHdvcmtlcnMgZnJvbSB3b3JrZXIgcG9vbCBvZiB3ZGlvIHJ1bm5lclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwaWNrQnkgICAgICAgICAgICAgZmlsdGVyIGJ5IHByb3BlcnR5IHZhbHVlIChzZWUgbG9kYXNoLnBpY2tCeSlcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSAgaW5jbHVkZUJ1c3lXb3JrZXIgIGRvbid0IGZpbHRlciBvdXQgYnVzeSB3b3JrZXIgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggd29ya2VycywgZS5nLiB7JzAtMCc6IHsgLi4uIH19XG4gICAgICovXG4gICAgZ2V0V29ya2VycyAocGlja0J5Rm4sIGluY2x1ZGVCdXN5V29ya2VyKSB7XG4gICAgICAgIGxldCB3b3JrZXJzID0gdGhpcy5sYXVuY2hlci5ydW5uZXIud29ya2VyUG9vbFxuXG4gICAgICAgIGlmICh0eXBlb2YgcGlja0J5Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdvcmtlcnMgPSBwaWNrQnkod29ya2VycywgcGlja0J5Rm4pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsdGVyIG91dCBidXN5IHdvcmtlcnMsIG9ubHkgc2tpcCBpZiBleHBsaWNpdGVseSBkZXNpcmVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWluY2x1ZGVCdXN5V29ya2VyKSB7XG4gICAgICAgICAgICB3b3JrZXJzID0gcGlja0J5KHdvcmtlcnMsICh3b3JrZXIpID0+ICF3b3JrZXIuaXNCdXN5KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdvcmtlcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBydW4gd29ya2VycyB3aXRoIHBhcmFtc1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gW3BhcmFtcz17fV0gIHBhcmFtZXRlcnMgdG8gcnVuIHRoZSB3b3JrZXIgd2l0aFxuICAgICAqL1xuICAgIHJ1biAocGFyYW1zID0ge30pIHtcbiAgICAgICAgY29uc3Qgd29ya2VycyA9IHRoaXMuZ2V0V29ya2VycyhcbiAgICAgICAgICAgIHBhcmFtcy5zcGVjID8gKHdvcmtlcikgPT4gd29ya2VyLnNwZWNzLmluY2x1ZGVzKHBhcmFtcy5zcGVjKSA6IG51bGwpXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRvbid0IGRvIGFueXRoaW5nIGlmIG5vIHdvcmtlciB3YXMgZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh3b3JrZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFuIHVwIGludGVyZmFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhblVwKClcblxuICAgICAgICAvKipcbiAgICAgICAgICogdXBkYXRlIHRvdGFsIHdvcmtlciBjb3VudCBpbnRlcmZhY2VcbiAgICAgICAgICogVG9EbzogdGhpcyBzaG91bGQgaGF2ZSBhIGNsZWFuZXIgc29sdXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGF1bmNoZXIuaW50ZXJmYWNlLnRvdGFsV29ya2VyQ250ID0gT2JqZWN0LmVudHJpZXMod29ya2VycykubGVuZ3RoXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyaWdnZXIgbmV3IHJ1biBmb3Igbm9uIGJ1c3kgd29ya2VyXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGNvbnN0IFssIHdvcmtlcl0gb2YgT2JqZWN0LmVudHJpZXMod29ya2VycykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2lkLCBjYXBzLCBzcGVjcywgc2Vzc2lvbklkIH0gPSB3b3JrZXJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3YgPSBPYmplY3QuYXNzaWduKHsgc2Vzc2lvbklkIH0sIHBhcmFtcylcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSgncnVuJywgYXJndilcbiAgICAgICAgICAgIHRoaXMubGF1bmNoZXIuaW50ZXJmYWNlLmVtaXQoJ2pvYjpzdGFydCcsIHsgY2lkLCBjYXBzLCBzcGVjcyB9KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYW5VcCAoKSB7XG4gICAgICAgIHRoaXMubGF1bmNoZXIuaW50ZXJmYWNlLnNldHVwKClcbiAgICAgICAgdGhpcy5sYXVuY2hlci5pbnRlcmZhY2UudXBkYXRlVmlldygpXG4gICAgfVxufVxuIl19